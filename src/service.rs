use super::server::Request;
use occams_rpc_core::{Codec, error::RpcIntErr};
use rustc_hash::FxHashMap;
use std::sync::Arc;

/// Service handling code generated by macro
///
/// A ServiceStatic can be:
/// - #[service]: a class with multi method, if only one service, ignore `req.service`.
/// - #[service_mux_struct]: a struct that contains serveral service, each field is a service,
/// match `req.service` by `ServiceTrait::ServiceName` field
pub trait ServiceStatic<C: Codec>: Send + Sync + 'static + Sized {
    /// For server_mux_struct to match
    const SERVICE_NAME: &'static str;

    /// match req.method
    ///     match req.decode::<RequestType>() {
    ///         Err(())=>{
    ///             req.set_error(occams_rpc_core::error::RPC_ERR_DECODE);
    ///             returnl
    ///         }
    ///         Ok(arg)=>{
    ///             match self.#method(arg).await {
    ///                 Ok(resp)=>{
    ///                     req.set_result(resp);
    ///                 }
    ///                 Err(e)=>{
    ///                     req.set_error()
    ///                 }
    ///             }
    ///         }
    ///     }
    fn serve(&self, req: Request<C>) -> impl Future<Output = ()> + Send + Sized;
}

impl<S: ServiceStatic<C>, C: Codec> ServiceStatic<C> for Arc<S> {
    const SERVICE_NAME: &'static str = S::SERVICE_NAME;

    #[inline(always)]
    fn serve(&self, req: Request<C>) -> impl Future<Output = ()> + Send + Sized {
        self.as_ref().serve(req)
    }
}

/// This is the async_trait version of Service trait
///
/// cannot be used by #[service_mux_struct], only used by ServiceMuxDyn
#[async_trait::async_trait]
pub trait ServiceDyn<C: Codec>: Send + Sync + 'static {
    fn get_service_name(&self) -> &'static str;

    async fn serve_dyn(&self, req: Request<C>);
}

#[async_trait::async_trait]
impl<S: ServiceStatic<C>, C: Codec> ServiceDyn<C> for S {
    #[inline(always)]
    fn get_service_name(&self) -> &'static str {
        <Self as ServiceStatic<C>>::SERVICE_NAME
    }

    #[inline(always)]
    async fn serve_dyn(&self, req: Request<C>) {
        self.serve(req).await
    }
}

/// A Service mux dispatch with hashmap
///
/// Only accepts ServiceDyn register, but provide ServiceDyn and ServiceStatic for calling
pub struct ServiceMuxDyn<C: Codec> {
    map: FxHashMap<&'static str, Arc<dyn ServiceDyn<C>>>,
}

impl<C: Codec> ServiceMuxDyn<C> {
    #[inline]
    pub fn new() -> Self {
        Self { map: Default::default() }
    }

    #[inline]
    pub fn add(&mut self, service: Arc<dyn ServiceDyn<C>>) {
        self.map.insert(service.get_service_name(), service);
    }
}

impl<C: Codec> ServiceStatic<C> for ServiceMuxDyn<C> {
    const SERVICE_NAME: &'static str = "";

    #[inline(always)]
    fn serve(&self, req: Request<C>) -> impl Future<Output = ()> + Send + Sized {
        async move {
            if let Some(service) = self.map.get(req.service.as_str()) {
                service.serve_dyn(req).await
            } else {
                req.set_rpc_error(RpcIntErr::Service);
            }
        }
    }
}

/*
pub struct ApiReqDispatch<C: Codec> {
    codec: C,
    service_dispatch:
}


impl<C: Codec> ReqDispatch<RespReceiverAPI> for D {

    async fn dispatch_req<'a>(
        &'a self, req: RpcSvrReq<'a>, noti: RespNoti<Response>,
    ) -> Result<(), ()> {
        if let RpcAction::Str(action) = req.action {
            if let Some(service, method) = action.split_once('.') {

            }
        }
        warn!("{:?} invalid action", req);
        return Err(())
    }
}

pub trait ServiceDisptach {

    fn dispatch(&self, req: Request<C>) -> impl Future<Output=()> + Send;
}
*/
