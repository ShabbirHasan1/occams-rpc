The API interface

A Service is defined by user, should be:
- called with immutable &self, because on the server-side, we want it to have Sync
- we should make client-side be able use the same trait, to leverage static check of rust compiler.
- Although the service handler will not return RpcIntErr, but the client-side might get a RpcIntErr from connection,
 the service method should return Result<(), RpcError<E>>, Where E is the user defined error which implements RpcErrCodec.
- All the method in the trait should be `async fn` or `impl Future`, optionally wrapped by async_trait. (Because the client-side is only async)

In each Request, contains `service` field, which should mach service name (in PascalCase), `method` field, mach the trait method name (in lower_case). (This rule is the same with GRPC)

At the client-side. there should be:

- Client Rounter : To choose from the server address pool, and handle fallback
- RpcClient: from occams-rpc-stream::client_impl::RpcClient.
- Clientfactor: implements occams-rpc-stream::client::ClientFactory
- ServiceClient: which implements trait that defined by user for service interface, generated by macros

which looks like:

```

pub struct ClientHandle<R: ClientRouter<F>, F: ClientFactory> {} // provide by the framework

pub trait DemoService {

    async fn foo() -> Result<(), RpcError<MyError>>;
}


#[client(DemoService)]
pub struct DemoClient (ClientHandle<...>);

```

The client macro attribute will impl DemoService trait with it, and other necessary stuff.

In the user coroutine.  call DemoClient::new() wrapes a ClientRouter<ClientFactory>, you get a context handle.
You can modify the timeout for this call, and other stretagy in the context.
Because The ServiceClient impl the user defined Service trait, it is without Sync marker, to prevent concurrent use.

```
let demo = DemoClient::new();
demo.foo().await
```
